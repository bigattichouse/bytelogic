(module
;; Generated ByteLog WebAssembly module
;; Math function imports
  (import "Math" "sin" (func $sin (param f64) (result f64)))
  (import "Math" "cos" (func $cos (param f64) (result f64)))
  (import "Math" "tan" (func $tan (param f64) (result f64)))
  (import "Math" "log" (func $log (param f64) (result f64)))
  (import "Math" "pow" (func $pow (param f64) (param f64) (result f64)))

  (memory 1)
;; Data section with atom names
;; Fact database functions
  (func $hash_fact (param $rel i32) (param $a i32) (param $b i32) (result i32)
    ;; Simple hash: (rel * 31 + a) * 31 + b
    local.get $rel
    i32.const 31
    i32.mul
    local.get $a
    i32.add
    i32.const 31
    i32.mul
    local.get $b
    i32.add
    i32.const 1000
    i32.rem_u
  )

  (func $add_fact (param $rel i32) (param $a i32) (param $b i32)
    (local $offset i32)
    ;; Calculate memory offset for fact
    local.get $rel
    local.get $a
    local.get $b
    call $hash_fact
    i32.const 12
    i32.mul
    local.set $offset
    ;; Store fact in memory
    local.get $offset
    local.get $rel
    i32.store
    local.get $offset
    i32.const 4
    i32.add
    local.get $a
    i32.store
    local.get $offset
    i32.const 8
    i32.add
    local.get $b
    i32.store
  )

  (func $has_fact (param $rel i32) (param $a i32) (param $b i32) (result i32)
    (local $offset i32)
    (local $stored_rel i32)
    (local $stored_a i32)
    (local $stored_b i32)
    ;; Calculate memory offset
    local.get $rel
    local.get $a
    local.get $b
    call $hash_fact
    i32.const 12
    i32.mul
    local.set $offset
    ;; Load stored values
    local.get $offset
    i32.load
    local.set $stored_rel
    local.get $offset
    i32.const 4
    i32.add
    i32.load
    local.set $stored_a
    local.get $offset
    i32.const 8
    i32.add
    i32.load
    local.set $stored_b
    ;; Compare values
    local.get $stored_rel
    local.get $rel
    i32.eq
    local.get $stored_a
    local.get $a
    i32.eq
    i32.and
    local.get $stored_b
    local.get $b
    i32.eq
    i32.and
  )

;; Rule evaluation functions
  (func $rule_birthday_person_0
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

  (func $rule_age_person_1
    ;; Rule evaluation stub
    ;; TODO: Implement actual rule logic
  )

;; Query functions
  (func $query_0 (result i32)
    ;; Query: birthday(0, ?)
    i32.const 1
  )

  (func $query_1 (result i32)
    ;; Query: birthday(1, ?)
    i32.const 1
  )

  (func $query_2 (result i32)
    ;; Query: age(2, ?)
    i32.const 1
  )

  (func $query_3 (result i32)
    ;; Query: age(0, ?)
    i32.const 1
  )

;; Main execution function
  (func $main
    ;; Add fact: birthday(0, 4)
    i32.const 8
    i32.const 0
    i32.const 4
    call $add_fact

    ;; Add fact: birthday(1, 9)
    i32.const 8
    i32.const 1
    i32.const 9
    call $add_fact

    ;; Add fact: age(2, 7)
    i32.const 3
    i32.const 2
    i32.const 7
    call $add_fact

    ;; Add fact: age(0, 8)
    i32.const 3
    i32.const 0
    i32.const 8
    call $add_fact

    ;; Add fact: person(0, 0)
    i32.const 6
    i32.const 0
    i32.const 0
    call $add_fact

    ;; Add fact: person(2, 2)
    i32.const 6
    i32.const 2
    i32.const 2
    call $add_fact

    ;; Add fact: person(1, 1)
    i32.const 6
    i32.const 1
    i32.const 1
    call $add_fact

;; TODO: Evaluate rules here
  )

;; Exports for JavaScript interface
  (export "main" (func $main))
  (export "memory" (memory 0))
  (export "add_fact" (func $add_fact))
  (export "has_fact" (func $has_fact))

)
